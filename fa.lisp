(defpackage finite-automata
  (:use :cl))

(in-package :finite-automata)

(defmacro if-let ((var val) then &optional else)
  `(let ((,var ,val))
     (if ,var ,then ,else)))

(defun notation (exp &optional vars)
  (let (variables (num-operations 0))
    (labels ((infix-binding-power (op)
               (case op
                 (union (values 1 2))
                 (|)| (values nil nil '|)|))
                 (t (values 3 4 'concatenation))))
             (postfix-binding-power (op)
               (case op
                 (star 10)
                 (t nil)))
             (infix->prefix (min-bp)
               (loop with lhs = (let ((lhs (pop exp)))
                                  (case lhs
                                    (|(| (prog1 (infix->prefix 0)
                                           (unless (eq (pop exp) '|)|)
                                             (error "No closing parenthesis somewhere lol"))))
                                    ((cat) (list lhs (infix->prefix lhs)))
                                    (t lhs)))
                     for op = (car exp)
                     do (unless op (loop-finish))
                        (block thing
                          (multiple-value-bind (lhs-bp) (postfix-binding-power op)
                            (when lhs-bp
                              (when (< lhs-bp min-bp)
                                (loop-finish))
                              (pop exp)
                              (setf lhs (list op lhs))
                              (return-from thing)))
                          (multiple-value-bind (lhs-bp rhs-bp special) (infix-binding-power op)
                            (cond ((or (eq special '|)|) (< lhs-bp min-bp))
                                   (loop-finish))
                                  ((eq special 'concatenation)
                                   (incf num-operations)
                                   (setf op 'cat))
                                  (t
                                   (pop exp)))
                            (setf lhs (list op lhs (infix->prefix rhs-bp)))))
                     finally (return lhs)))
             (lex (exp)
               (loop for x across exp
                     append (cond ((alphanumericp x)
                                   (let ((a (read-from-string (string x))))
                                     (pushnew a variables)
                                     (list a)))
                                  (t
                                   (case x
                                     ((#\+) (prog1 '(union) (incf num-operations)))
                                     ((#\*) (prog1 '(star) (incf num-operations)))
                                     ((#\() '(|(|))
                                     ((#\)) '(|)|))
                                     ((#\space))
                                     ((#\tab))
                                     (t (error "wot in tarnation is '~a' doing here" x))))))))
      (setf exp (lex exp))
      (values (infix->prefix 0) (union vars variables) num-operations))))

(defun notate (exp &optional vars)
  (nth-value 0 (notation exp vars)))


(defun traverse-regexp (regexp vertex)
  (cond ((listp regexp)
         (case (first regexp)
           (union (let ((lhs-vertex (gensym))
                        (rhs-vertex (gensym)))
                    (multiple-value-bind (lhs lhs-accept-state) (traverse-regexp (second regexp) lhs-vertex)
                      (multiple-value-bind (rhs rhs-accept-state) (traverse-regexp (third regexp) rhs-vertex)
                        (values (append lhs rhs (list (list vertex (cons nil (list lhs-vertex rhs-vertex))))) (append lhs-accept-state rhs-accept-state))))))
           (cat (multiple-value-bind (lhs lhs-accept-state) (traverse-regexp (second regexp) vertex)
                  (multiple-value-bind (rhs rhs-accept-state) (traverse-regexp (third regexp) (first lhs-accept-state))
                    (values (append lhs rhs) rhs-accept-state))))
           (star (multiple-value-bind (graph accept-state) (traverse-regexp (second regexp) vertex)
                   (values (append graph (loop for accept in accept-state collect (list accept (list nil vertex))))
                           (list* vertex accept-state))))
           (otherwise (error "wut operation is this: ~a" (first regexp)))))
        ((atom regexp)
         (let ((accept-state (gensym)))
           (values (list (list vertex (cons regexp accept-state)))
                   (list accept-state))))))

(defun execute-finite-automata (input accept-states graph &optional (start-state 'start))
  (declare (optimize (debug 3) (safety 3)))
  (labels ((execute (start-idx current-state branch)
             (loop for idx from start-idx below (length input)
                   for symbol = (read-from-string (string (char input idx)))
                   do (let ((empty-set-vertex (cdr (assoc nil (cdr (assoc current-state graph))))))
                        (when (>= (length empty-set-vertex) 1)
                          (return (dolist (v empty-set-vertex)
                                    (if-let (accept (execute idx v (1+ branch)))
                                      (progn (return accept))))))
                        (if-let (vertex (cdr (assoc symbol (cdr (assoc current-state graph)))))
                          (setf current-state vertex)
                          (progn (return (values nil current-state)) )))
                   finally (return (if-let (accept (find current-state accept-states)) (values t current-state) (values nil current-state))))))
    (execute 0 start-state 0)))

(defun fa (input expr &optional print-graph)
  (let ((regexp (notate expr)))
    (multiple-value-bind (graph accept-states) (traverse-regexp regexp 'start)
      (multiple-value-bind (accepted final-state) (execute-finite-automata input accept-states graph)
        (when print-graph (format t "accepted: ~a~%graph: ~a~%accept states: ~a~%final state: ~a~%parsed: ~a" accepted graph accept-states final-state regexp))))))
