(defpackage finite-automata
  (:use :cl))

(in-package :finite-automata)

(defmacro if-let ((var val) then &optional else)
  `(let ((,var ,val))
     (if ,var ,then ,else)))

(defun notate (exp)
  (labels ((infix-binding-power (op)
             (case op
               (union (values 1 2))
               (|)| (values nil nil '|)|))
               (t (values 3 4 'cat))))
           (postfix-binding-power (op)
             (case op
               (star 10)
               (t nil)))
           (infix->prefix (min-bp)
             (loop with lhs = (let ((lhs (pop exp)))
                                (case lhs
                                  (|(| (prog1 (infix->prefix 0)
                                         (unless (eq (pop exp) '|)|)
                                           (error "No closing parenthesis somewhere lol"))))
                                  ((cat) (list lhs (infix->prefix lhs)))
                                  (t lhs)))
                   for op = (car exp)
                   do (unless op (loop-finish))
                      (block thing
                        (if-let (lhs-bp (postfix-binding-power op))
                          (progn
                            (when (< lhs-bp min-bp)
                              (loop-finish))
                            (pop exp)
                            (setf lhs (list op lhs))
                            (return-from thing)))
                        (multiple-value-bind (lhs-bp rhs-bp special) (infix-binding-power op)
                          (cond ((or (eq special '|)|) (< lhs-bp min-bp))
                                 (loop-finish))
                                ((eq special 'cat)
                                 (setf op 'cat))
                                (t
                                 (pop exp)))
                          (setf lhs (list op lhs (infix->prefix rhs-bp)))))
                   finally (return lhs)))
           (lex (exp)
             (loop for x across exp
                   append (cond ((alphanumericp x)
                                 (list (read-from-string (string x))))
                                (t
                                 (case x
                                   ((#\+) '(union))
                                   ((#\*) '(star))
                                   ((#\() '(|(|))
                                   ((#\)) '(|)|))
                                   ((#\space))
                                   ((#\tab))
                                   (t (error "wot in tarnation is '~a' doing here" x))))))))
    (setf exp (lex exp))
    (infix->prefix 0)))

(defun traverse-regexp (regexp vertex)
    (declare (optimize (debug 3) (safety 3)))
  (cond ((listp regexp)
         (case (first regexp)
           (union (let ((lhs-vertex (gensym))
                        (rhs-vertex (gensym)))
                    (multiple-value-bind (lhs lhs-accept-state) (traverse-regexp (second regexp) lhs-vertex)
                      (multiple-value-bind (rhs rhs-accept-state) (traverse-regexp (third regexp) rhs-vertex)
                        (values (append lhs rhs (list (list vertex (cons nil (list lhs-vertex rhs-vertex))))) (append lhs-accept-state rhs-accept-state))))))
           (cat (let ((lhs-vertex (gensym "lhs")))
                  (multiple-value-bind (lhs lhs-accept-state) (traverse-regexp (second regexp) lhs-vertex)
                    (multiple-value-bind (rhs rhs-accept-state) (traverse-regexp (third regexp) (first lhs-accept-state))
                      (values (append lhs rhs (list (list vertex (cons nil (list lhs-vertex)))))
                              (append rhs-accept-state))))))
           (star (let ((indirection-vertex (gensym "ind"))
                       (indirection2-vertex (gensym "2ind")))
                   (multiple-value-bind (graph accept-state) (traverse-regexp (second regexp) indirection-vertex)
                     (values (append graph (list (list vertex (cons nil (list indirection-vertex indirection2-vertex)))) (loop for accept in accept-state collect (list accept (list nil vertex))))
                             (list* indirection2-vertex  vertex accept-state)))))
           (otherwise (error "wut operation is this: ~a" (first regexp)))))
        ((atom regexp)
         (let ((accept-state (gensym "sym")))
           (values (list (list vertex (cons regexp accept-state)))
                   (list accept-state))))))

(defun execute-finite-automata (input accept-states graph &key (start-state 'start) debug-print)
  (declare (optimize (debug 3) (safety 3)))
  (labels ((debug-print (symbol branch custom)
             (when debug-print (format t "b~a ~a '~a'~%" branch custom symbol)))
           (crawl-empty-set-paths (idx current-state branch)
             (let ((empty-set-vertex (cdr (assoc nil (cdr (assoc current-state graph))))))
               (if (>= (length empty-set-vertex) 1)
                   (let ((cnt 0))
                     (dolist (v empty-set-vertex)
                       (multiple-value-bind (accepted state) (execute idx v (+ (* cnt 11) (1+ branch)))
                         (if accepted
                             (return (progn (debug-print 'placeholder branch "SUCCEED0") (values t state))) ))
                       (incf cnt)))
                   nil)))
           (execute (start-idx current-state branch)
             (loop for idx from start-idx below (length input)
                   for symbol = (read-from-string (string (char input idx)))
                   do (debug-print symbol branch current-state)
                      (multiple-value-bind (accepted state) (crawl-empty-set-paths idx current-state branch)
                        (when accepted (return (values accepted state))))
                      (if-let (vertex (cdr (assoc symbol (cdr (assoc current-state graph)))))
                        (setf current-state vertex)
                        (return (progn (debug-print symbol branch "FAIL1") (values nil current-state))))
                   finally (return (if-let (accept (find current-state accept-states))
                                     (progn (debug-print symbol branch "SUCCEED2") (values t current-state))
                                     (progn (debug-print symbol branch "FAIL2") (values nil current-state)))))))
    (if (zerop (length input))
        (crawl-empty-set-paths 0 start-state 0)
        (execute 0 start-state 0))))

(defun fa (input expr &optional print-graph)
  (let ((regexp (notate expr)))
    (multiple-value-bind (graph accept-states) (traverse-regexp regexp 'start)
      (multiple-value-bind (accepted final-state) (execute-finite-automata input accept-states graph :debug-print print-graph)
        (when print-graph (format t "accepted: ~a~%graph: ~a~%accept states: ~a~%final state: ~a~%parsed: ~a" accepted graph accept-states final-state regexp))))))
